---
name: debug
description: 遇到任何 bug、测试失败或意外行为时使用。在尝试修复前，必须先完成根因调查。
---

# 系统化调试 (Systematic Debugging)

## 概述

随意修复浪费时间并产生新 bug。快速补丁掩盖根本问题。

**核心原则：始终在尝试修复前找到根因。修复症状即为失败。**

**违反流程的字面规定即违反调试的精神。**

## 铁律 (The Iron Law)

```
NO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST
未经根因调查，禁止任何修复
```

如果您未完成阶段 1（根因调查），则不能提出修复方案。

## 何时使用

用于**任何**技术问题：
- 测试失败
- 生产环境 bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**尤其在以下情况必须使用：**
- 时间紧迫（紧急情况让猜测更诱人）
- "只需一个快速修复"看似明显
- 已经尝试过多次修复
- 之前的修复无效
- 您不完全理解问题

**不要跳过流程当：**
- 问题看似简单（简单 bug 也有根因）
- 您很着急（急躁保证返工）
- 管理层要求立即修复（系统化比混乱摸索更快）

## 四个阶段

您**必须**完成每个阶段才能进入下一阶段。

### 阶段 1：根因调查

**在尝试任何修复之前：**

1. **仔细阅读错误信息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 记录行号、文件路径、错误代码

2. **一致地重现问题**
   - 能否可靠地触发？
   - 确切的步骤是什么？
   - 每次都发生吗？
   - 如果无法重现 → 收集更多数据，不要猜测

3. **检查最近的更改**
   - 哪些更改可能导致此问题？
   - `git diff`、最近的提交
   - 新的依赖项、配置更改
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件时（CI → 构建 → 签名，API → 服务 → 数据库）：**

   **在提出修复前，添加诊断日志：**
   ```
   对于每个组件边界：
     - 记录进入组件的数据
     - 记录离开组件的数据
     - 验证环境/配置传播
     - 检查每一层的状态

   运行一次以收集证据，显示在哪里中断
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

   **示例（多层系统）：**
   ```bash
   # 层 1：工作流
   echo "=== 工作流中可用的密钥: ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # 层 2：构建脚本
   echo "=== 构建脚本中的环境变量: ==="
   env | grep IDENTITY || echo "环境中没有 IDENTITY"

   # 层 3：签名脚本
   echo "=== 密钥链状态: ==="
   security list-keychains
   security find-identity -v

   # 层 4：实际签名
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **这揭示了：** 哪一层失败（密钥 → 工作流 ✓，工作流 → 构建 ✗）

5. **追踪数据流**

   **当错误位于调用堆栈深处时：**

   参见本目录中的 `root-cause-tracing.md` 以了解完整的向后追踪技术。

   **快速版本：**
   - 错误值从哪里产生？
   - 谁用错误值调用了这个？
   - 继续向上追踪直到找到源头
   - 在源头修复，而不是在症状处

### 阶段 2：模式分析

**在修复前找到模式：**

1. **查找有效示例**
   - 在同一代码库中找到类似的有效代码
   - 什么有效的代码与损坏的相似？

2. **与参考对比**
   - 如果实现模式，**完整**阅读参考实现
   - 不要略读 - 阅读每一行
   - 在应用前完全理解模式

3. **识别差异**
   - 有效和损坏之间有什么不同？
   - 列出每个差异，无论多小
   - 不要假设"那不可能有影响"

4. **理解依赖项**
   - 这需要哪些其他组件？
   - 需要什么设置、配置、环境？
   - 它做了什么假设？

### 阶段 3：假设和测试

**科学方法：**

1. **形成单一假设**
   - 清楚陈述："我认为 X 是根因，因为 Y"
   - 写下来
   - 要具体，不要模糊

2. **最小化测试**
   - 做**最小**可能的更改来测试假设
   - 一次一个变量
   - 不要同时修复多个东西

3. **继续前验证**
   - 有效吗？是 → 阶段 4
   - 无效？形成新假设
   - 不要在上面叠加更多修复

4. **当您不知道时**
   - 说"我不理解 X"
   - 不要假装知道
   - 寻求帮助
   - 进一步研究

### 阶段 4：实施

**修复根因，而不是症状：**

1. **创建失败的测试用例**
   - 最简单的重现
   - 如果可能，自动化测试
   - 如果没有框架，一次性测试脚本
   - 修复前必须有
   - 使用 `test-driven-development` skill 编写适当的失败测试

2. **实施单一修复**
   - 解决已识别的根因
   - 一次一个更改
   - 没有"既然在这"的改进
   - 没有捆绑重构

3. **验证修复**
   - 测试现在通过了？
   - 没有破坏其他测试？
   - 问题真的解决了？

4. **如果修复无效**
   - 停止
   - 计数：您尝试了多少次修复？
   - 如果 < 3：返回阶段 1，用新信息重新分析
   - **如果 ≥ 3：停止并质疑架构（见下面步骤 5）**
   - 不要在没有架构讨论的情况下尝试修复 #4

5. **如果 3+ 次修复失败：质疑架构**

   **表明架构问题的模式：**
   - 每次修复都揭示新的共享状态/耦合/问题在不同地方
   - 修复需要"大规模重构"才能实施
   - 每次修复在其他地方产生新症状

   **停止并质疑基础：**
   - 这种模式根本上是否合理？
   - 我们是否"因惯性而坚持"？
   - 我们应该重构架构还是继续修复症状？

   **在尝试更多修复前与用户讨论**

   这不是失败的假设 - 这是错误的架构。

## 红旗清单 - 停止并遵循流程

如果您发现自己在想：
- "现在快速修复，稍后调查"
- "只需尝试更改 X 看看是否有效"
- "添加多个更改，运行测试"
- "跳过测试，我会手动验证"
- "可能是 X，让我修复它"
- "我不完全理解但这可能有效"
- "模式说 X 但我会以不同方式调整它"
- "以下是主要问题：[在调查前列出修复]"
- 在追踪数据流前提出解决方案
- **"再尝试一次修复"（当已经尝试 2+ 次时）**
- **每次修复都揭示不同地方的新问题**

**所有这些都意味着：停止。返回阶段 1。**

**如果 3+ 次修复失败：** 质疑架构（见阶段 4.5）

## 用户信号表明您做错了

**注意这些重定向：**
- "那不是正在发生吗？" - 您在没有验证的情况下假设
- "它会向我们显示...吗？" - 您应该添加证据收集
- "停止猜测" - 您在没有理解的情况下提出修复
- "仔细思考这个" - 质疑基础，而不仅仅是症状
- "我们卡住了？"（沮丧）- 您的方法不起作用

**当您看到这些时：** 停止。返回阶段 1。

## 常见合理化借口

| 借口 | 现实 |
|------|------|
| "问题简单，不需要流程" | 简单问题也有根因。流程对简单 bug 很快。 |
| "紧急，没时间流程" | 系统化调试比猜测摸索更快。 |
| "先试试这个，然后调查" | 第一次修复设定模式。从一开始就做对。 |
| "确认修复有效后写测试" | 未测试的修复不持久。先测试证明它。 |
| "一次多次修复节省时间" | 无法隔离什么有效。导致新 bug。 |
| "参考太长，我会调整模式" | 部分理解保证 bug。完整阅读它。 |
| "我看到问题，让我修复它" | 看到症状 ≠ 理解根因。 |
| "再尝试一次修复"（在 2+ 次失败后） | 3+ 次失败 = 架构问题。质疑模式，不要再修复。 |

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|------|---------|---------|
| **1. 根因** | 阅读错误、重现、检查更改、收集证据 | 理解**什么**和**为什么** |
| **2. 模式** | 查找有效示例、对比 | 识别差异 |
| **3. 假设** | 形成理论、最小化测试 | 确认或新假设 |
| **4. 实施** | 创建测试、修复、验证 | Bug 解决、测试通过 |

## 当流程揭示"无根因"时

如果系统调查揭示问题确实是环境、时间依赖或外部的：

1. 您已完成流程
2. 记录您调查的内容
3. 实施适当的处理（重试、超时、错误消息）
4. 添加监控/日志以便将来调查

**但是：** 95% 的"无根因"情况是调查不完整。

## 支持技术

这些技术是系统化调试的一部分，在本目录中可用：

- **`root-cause-tracing.md`** - 通过调用堆栈向后追踪 bug 以找到原始触发器
- **`defense-in-depth.md`** - 在找到根因后在多层添加验证
- **`condition-based-waiting.md`** - 用条件轮询替换任意超时

**相关 skills：**
- **test-driven-development** - 用于创建失败的测试用例（阶段 4，步骤 1）
- **code-review** - 调试完成后，从审查中识别相关问题并关联修复

## 与项目流程集成

### 输入文件（根据场景可选）
- `prd.md` - 了解预期行为
- `cases.md` - 查看相关测试场景（TC-*）
- `design.md` - 理解技术设计意图
- `plan.md` - 查看原始实施计划

### 输出文件
- **调试报告**：`docs/debug/<YYYY-MM-DD>-<issue-id>/debug-report.md`
  - 使用本目录中的 `template.md` 模板
  - 记录四个阶段的调查过程
  - 记录根因和修复方案

### Git 提交规范

修复提交必须遵循 Conventional Commits 格式：

```
fix: <简短描述>

<详细说明>
Root Cause: <根因简述>
Covers: <TC-编号列表>
```

**示例：**
```
fix: 修复空 projectDir 导致的 git init 位置错误

通过向后追踪发现根因是测试 setup 在 beforeEach 前访问了 tempDir。
添加了四层防御验证确保问题不再发生。

Root Cause: 测试在 beforeEach 初始化前访问 context.tempDir
Covers: TC-FAULT-001, TC-BOUND-002
```

## 真实世界影响

基于调试会话：
- 系统化方法：15-30 分钟修复
- 随机修复方法：2-3 小时混乱
- 首次修复率：95% vs 40%
- 引入新 bug：接近零 vs 常见

## 最终规则

```
只有在找到根因并理解为什么后才修复
否则 → 不是调试，是猜测
```

未经用户许可不得例外。
