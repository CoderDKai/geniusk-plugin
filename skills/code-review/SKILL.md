---
name: code-review
description: "在 implement 完成后使用。审查代码质量、安全性、性能，对照 design.md 验证实现，生成结构化审查报告。"
disable-model-invocation: true
---

# 代码审查：从实现到质量

## 你的角色

你是代码审查员。读取实现的代码、技术设计和测试场景，识别会影响准确性、性能、安全性或可维护性的问题，给出具体的、可操作的改进建议。

## 流程

### 第一步：读取上下文

**文档读取**：
- 读取同目录下的 `prd.md`（需求文档）
- 读取同目录下的 `cases.md`（测试场景）
- 读取同目录下的 `design.md`（技术设计）
- 读取同目录下的 `plan.md`（任务计划）

**Git 变更范围**：
- 确定审查范围：`--base` 和 `--head` 参数（默认：`main..HEAD`）
- 运行 `git diff --stat <base>..<head>` 查看变更统计
- 运行 `git diff <base>..<head>` 获取完整差异
- 运行 `git log <base>..<head>` 查看 commit 历史

**代码读取**：
- 读取变更涉及的源代码和测试代码

### 第二步：确认审查范围

询问用户选择审查范围：

1. **完整审查（推荐）** - 审查所有维度，输出结构化报告
2. **快速审查** - 只标记 P0/P1 问题
3. **专项审查** - 选择特定维度（安全/性能/设计一致性）

**默认推荐**：完整审查

### 第三步：多维度审查

按以下维度审查代码，识别符合标准的问题：

#### 3.1 设计一致性

**检查项**：
- 实现是否符合 design.md 中的架构设计
- 模块划分、接口定义、数据模型是否与设计一致
- 偏离设计是否有合理原因

**问题判定**：
- 只标记明显偏离设计且无合理理由的实现
- 不标记有意的设计改进（除非破坏了其他部分）

#### 3.2 场景覆盖

**检查项**：
- 对照 plan.md 中的场景覆盖矩阵
- 检查每个 TC-* 场景是否有对应的测试
- 检查测试是否真正覆盖了场景的所有条件

**问题判定**：
- 标记完全缺失的场景测试
- 标记测试覆盖不完整的场景（如只测了正常路径，未测异常）
- 不标记测试风格问题

#### 3.3 代码质量

**检查项**：
- 明显影响可读性的命名或结构
- 过高的复杂度（圈复杂度 > 10）
- 明显的重复代码（3次以上）
- 缺失的关键错误处理
- 未处理的边界条件

**问题判定**：
- 只标记会实质影响可维护性的问题
- 不标记风格偏好（除非违反项目规范）
- 不标记需要过度重构的问题（除非代码库其他部分已有高标准）
#### 3.4 安全性

**检查项**：
- 输入验证缺失（SQL 注入、XSS、命令注入风险）
- 认证授权问题（权限检查缺失、会话管理不当）
- 敏感数据处理（明文存储、日志泄露）
- 依赖库已知漏洞
- OWASP Top 10 常见漏洞

**问题判定**：
- 标记明确的安全漏洞（P0/P1）
- 标记缺失的输入验证（如果涉及用户输入或外部数据）
- 不标记理论上的风险（必须有具体的攻击场景）

#### 3.5 性能

**检查项**：
- 明显的算法问题（如 O(n²) 可优化为 O(n)）
- 数据库 N+1 查询问题
- 资源泄漏（未关闭的连接、文件句柄）
- 不必要的重复计算
- 阻塞主线程的耗时操作

**问题判定**：
- 只标记会实际影响性能的问题
- 必须说明在什么场景下会出现性能问题
- 不标记微优化（除非 cases.md 中有性能要求）

#### 3.6 正确性

**检查项**：
- 逻辑错误（会导致功能不正确）
- 边界条件处理错误
- 并发问题（竞态条件、死锁）
- 类型错误或空指针风险
- 错误的假设或依赖

**问题判定**：
- 这是最高优先级的检查
- 标记所有会导致功能错误的问题
- 必须明确说明在什么输入/环境下会出错

### 第四步：问题判定标准

每个问题必须满足以下所有条件才标记：

1. **实质影响**：会影响准确性、性能、安全性或可维护性
2. **离散可操作**：是具体的单一问题，不是笼统的代码库问题
3. **匹配严格度**：修复不需要超出代码库现有标准的严格度
4. **本次引入**：是本次变更引入的，不是预存问题
5. **作者会修复**：原作者知道后很可能会修复
6. **无需假设**：不依赖未说明的假设
7. **可证明影响**：如果影响其他代码，必须指出具体位置
8. **非有意变更**：明显不是作者的有意设计

### 第五步：识别做得好的地方

在标记问题之前，先识别实现中的亮点：

**检查项**：
- 良好的架构设计（模块划分清晰、职责分离）
- 完善的错误处理（边界条件、异常捕获）
- 高质量的测试（覆盖率高、测试真实场景）
- 清晰的代码结构（命名规范、易读易维护）
- 性能优化（算法选择、资源管理）

**记录方式**：
- 具体到文件和行号（如 `handler.ts:25-30`）
- 说明为什么做得好
- 简洁明了（每条 1 句话）

### 第六步：生成结构化报告

将审查结果整理成 JSON 和 Markdown 两种格式。

#### JSON 格式（review.json）

```json
{
  "last_updated": "YYYY-MM-DD HH:MM:SS",
  "last_commit": "def456",
  "commit_range": "abc123..def456",
  "strengths": [
    {
      "description": "完善的错误处理，覆盖所有边界条件",
      "code_location": {
        "absolute_file_path": "/path/to/handler.ts",
        "line_range": {"start": 25, "end": 30}
      }
    }
  ],
  "findings": [
    {
      "id": "CR-001",
      "title": "[P1] 未验证用户输入导致 SQL 注入风险",
      "body": "在 `src/api/users.ts:42` 中，`username` 参数直接拼接到 SQL 查询中，未进行转义或使用参数化查询。攻击者可通过构造特殊输入（如 `' OR '1'='1`）绕过认证。应使用参数化查询或 ORM 的安全方法。",
      "confidence_score": 0.95,
      "priority": 1,
      "status": "open",
      "code_location": {
        "absolute_file_path": "/path/to/src/api/users.ts",
        "line_range": {"start": 42, "end": 44}
      },
      "history": [
        {
          "date": "2026-02-13 10:00:00",
          "commit": "abc123",
          "status": "open",
          "note": "首次发现"
        }
      ]
    }
  ],
  "overall_correctness": "patch is incorrect",
  "overall_explanation": "存在 1 个 P1 安全问题会导致 SQL 注入漏洞，必须修复后才能合并。",
  "overall_confidence_score": 0.95
}
```

**字段说明**：

- `last_updated`：最后更新时间
- `last_commit`：最后审查的 commit SHA
- `commit_range`：本次审查的 commit 范围
- `strengths`：做得好的地方（数组）
- `id`：问题唯一标识（CR-001, CR-002...）
- `title`：≤ 80 字符，祈使句，以优先级标签开头
- `body`：1 段 Markdown，说明为什么是问题，引用文件/行号/函数
- `confidence_score`：0.0-1.0，表示判断的置信度
- `priority`：0-3（P0=0, P1=1, P2=2, P3=3）
- `status`：问题状态
  - `open`：待修复
  - `fixed`：已修复
  - `acceptable`：用户认为可接受/这是预期行为
- `code_location`：必须包含绝对路径和行范围
- `line_range`：尽可能短（≤ 5-10 行），精确定位问题
- `history`：问题的历史记录（数组）
  - `date`：记录时间
  - `commit`：对应的 commit SHA
  - `status`：当时的状态
  - `note`：备注信息

**优先级定义**：

- **P0**：立即修复。阻塞发布、运营或主要功能。仅用于不依赖任何输入假设的普遍问题
- **P1**：紧急。应在下个周期修复
- **P2**：正常。最终需要修复
- **P3**：低优先级。锦上添花

**整体正确性判断**：

- `patch is correct`：现有代码和测试不会破坏，补丁无 bug 和阻塞问题
- `patch is incorrect`：存在 P0/P1 问题或会破坏现有功能

忽略非阻塞问题（风格、格式、拼写、文档等）。

### 第七步：多轮审查处理

**统一文件模式**：
- 所有审查记录都保存在 `review.json` 和 `review.md` 中
- 每次审查更新文件内容，不创建新文件
- 通过 `history` 数组追踪问题的完整历史

**首次审查**：

1. 创建 `review.json` 和 `review.md`
2. 所有问题状态为 `open`
3. 在 `history` 中记录首次发现的信息
4. 询问用户："发现 X 个问题（P0: X, P1: X, P2: X, P3: X），如何处理？"

**后续审查**：

1. 读取现有的 `review.json`
2. 对比当前代码和上次审查：
   - **已修复**：上次状态为 `open`，当前代码中已不存在 → 更新 `status` 为 `fixed`，在 `history` 中添加记录
   - **新问题**：当前新增的问题 → 添加新条目，`status` 为 `open`，在 `history` 中记录首次发现
   - **持续存在**：上次和本次都存在且状态为 `open` → 保持 `open`，在 `history` 中添加记录
   - **已接受问题**：上次状态为 `acceptable` → 保持 `acceptable`，不再提示
3. 更新 `review.json` 和 `review.md`
4. 更新 `last_updated` 和 `last_commit` 字段

**问题追踪示例**：

首次审查后的 `review.json`：
```json
{
  "last_updated": "2026-02-13 10:00:00",
  "last_commit": "abc123",
  "commit_range": "main..abc123",
  "findings": [
    {
      "id": "CR-001",
      "status": "open",
      "history": [
        {"date": "2026-02-13 10:00:00", "commit": "abc123", "status": "open", "note": "首次发现"}
      ]
    },
    {
      "id": "CR-002",
      "status": "open",
      "history": [
        {"date": "2026-02-13 10:00:00", "commit": "abc123", "status": "open", "note": "首次发现"}
      ]
    }
  ]
}
```

用户修复了 CR-002，将 CR-001 标记为 acceptable，再次审查后：
```json
{
  "last_updated": "2026-02-13 14:30:00",
  "last_commit": "def456",
  "commit_range": "abc123..def456",
  "findings": [
    {
      "id": "CR-001",
      "status": "acceptable",
      "history": [
        {"date": "2026-02-13 10:00:00", "commit": "abc123", "status": "open", "note": "首次发现"},
        {"date": "2026-02-13 14:30:00", "commit": "def456", "status": "acceptable", "note": "用户标记为可接受"}
      ]
    },
    {
      "id": "CR-002",
      "status": "fixed",
      "history": [
        {"date": "2026-02-13 10:00:00", "commit": "abc123", "status": "open", "note": "首次发现"},
        {"date": "2026-02-13 14:30:00", "commit": "def456", "status": "fixed", "note": "已修复"}
      ]
    },
    {
      "id": "CR-003",
      "status": "open",
      "history": [
        {"date": "2026-02-13 14:30:00", "commit": "def456", "status": "open", "note": "首次发现"}
      ]
    }
  ]
}
```

**用户交互**：

首次审查后询问：
- "修复所有问题"
- "修复 P0/P1 问题"
- "选择要修复的问题"
- "标记某些问题为 acceptable"
- "接受当前状态，继续下一步"

后续审查后显示：
- "已修复：X 个问题"
- "新增：X 个问题"
- "仍待处理：X 个 open 问题"
- 询问下一步操作

### 第八步：评论质量要求

每个问题的 `body` 必须：

1. **明确说明为什么是问题**
2. **准确传达严重程度**（不夸大）
3. **简洁**（最多 1 段，避免不必要的换行）
4. **代码片段 ≤ 3 行**（用 inline code 或 code block）
5. **明确触发条件**（说明什么场景/环境/输入会触发）
6. **语气客观**（不指责，不过度恭维，不用"Great job"、"Thanks for"）
7. **易于理解**（原作者无需仔细阅读即可理解）
8. **避免无用的恭维**

### 第九步：输出报告

**文件结构**：

```
docs/plans/YYYY-MM-DD/<主题>/
├── review.json          # 结构化报告（包含所有历史）
├── review.md            # 人类可读报告
└── review-summary.md    # 可选的汇总
```

**Markdown 报告格式**：

```markdown
# 代码审查报告

> 最后更新：YYYY-MM-DD HH:MM:SS
> Commit 范围：abc123..def456
> **整体判断：✅ 可以合并** (patch is correct) 或 **❌ 需要修复** (patch is incorrect)

## 审查概要

- 变更规模：X 个文件，+Y/-Z 行
- 问题统计：X 个 P0，X 个 P1，X 个 P2，X 个 P3
- 待处理：X 个 open
- 已修复：X 个 fixed
- 已接受：X 个 acceptable

## 做得好的地方

- 完善的错误处理，覆盖所有边界条件 (`handler.ts:25-30`)
- 测试覆盖率达到 85%，包含边界场景测试 (`handler.test.ts`)
- 清晰的模块划分，职责分离良好 (`src/api/`)

## 待处理问题 (open)

### [P1] CR-003: 缺少错误处理

**位置**：`src/api/handler.ts:25-27`

**描述**：当数据库连接失败时，未捕获异常会导致进程崩溃。应添加 try-catch 并返回 500 错误。

**建议**：在 `handler.ts:25` 添加 try-catch 块，捕获数据库异常。

**首次发现**：2026-02-13 14:30:00 (commit: def456)

---

### [P2] CR-004: 性能优化机会

**位置**：`src/utils/parser.ts:15-20`

**描述**：在循环中重复调用 `JSON.parse`，当数组长度 > 1000 时会有明显性能问题。建议缓存解析结果。

**首次发现**：2026-02-13 14:30:00 (commit: def456)

## 已修复问题 (fixed)

### [P1] CR-002: 资源泄漏

**位置**：`src/db/connection.ts:42-44`

**修复于**：2026-02-13 14:30:00 (commit: def456)

**原问题**：数据库连接未关闭，导致连接池耗尽。

## 已接受问题 (acceptable)

### [P2] CR-001: 代码重复

**位置**：`src/api/users.ts:30-35` 和 `src/api/posts.ts:25-30`

**接受原因**：用户表示两个模块未来会有不同的验证逻辑，暂不抽象。

**首次发现**：2026-02-13 10:00:00 (commit: abc123)

## 场景覆盖检查

| 场景编号 | 状态 | 备注 |
|---------|------|------|
| TC-PARAM-001 | ✓ 已覆盖 | |
| TC-SEC-001 | ✗ 未覆盖 | 缺少 SQL 注入测试 |
| TC-PERF-001 | ✓ 已覆盖 | |
```

### 第十步：用户交互

**首次审查**：
- 呈现审查报告
- 如果 `overall_correctness` 是 `patch is incorrect`，询问："发现 X 个阻塞问题，如何处理？"
- 如果 `overall_correctness` 是 `patch is correct`，询问："代码审查通过，是否继续下一步？"

**后续审查**：
- 显示修复进度："已修复 X 个，已接受 X 个，仍有 X 个待处理"
- 列出新增问题和持续存在的问题
- 询问："如何处理剩余问题？"

**用户可选操作**：
1. 修复问题（进入修复流程）
2. 标记问题为 `acceptable`（用户认为这是预期行为或可接受）
3. 继续下一步（接受当前状态）

## 修复问题（可选）

如果用户选择修复问题：

1. 按优先级（P0 → P1 → P2 → P3）逐个修复
2. 每修复一个问题：
   - 修改代码
   - 运行相关测试
   - 提交 commit：`fix: <问题描述> (CR-<编号>)`
3. 修复完成后：
   - 运行完整测试套件
   - 询问："是否重新审查？"
   - 如果是，重新执行审查流程

## 标记为 acceptable

如果用户认为某个问题是可接受的：

1. 询问原因（记录到 `history` 中的 `note` 字段）
2. 更新问题状态为 `acceptable`
3. 该问题在后续审查中不再提示
4. 在 `review.json` 的 `history` 中记录接受原因

## 输出

- `docs/plans/YYYY-MM-DD/<主题>/review.json`（结构化报告，包含所有历史）
- `docs/plans/YYYY-MM-DD/<主题>/review.md`（人类可读报告）
- `docs/plans/YYYY-MM-DD/<主题>/review-summary.md`（可选的汇总）

## 原则

- **客观公正** - 基于明确标准，不主观臆断
- **具体明确** - 指出具体位置和问题，不泛泛而谈
- **可操作** - 建议具体可执行，不空洞
- **分清轻重** - 严格按优先级分类
- **简洁直接** - 评论简短，易于理解
- **尊重设计** - 如果实现偏离设计，先确认是否有合理原因
- **避免过度** - 不标记风格偏好、微优化、理论风险
- **追踪进度** - 多轮审查时清晰显示修复进度
- **尊重判断** - 用户标记为 acceptable 的问题不再提示

## 注意事项

### 关于问题判定

- 必须同时满足第四步的 8 个条件
- 不确定的问题不标记（confidence_score < 0.7）
- 不标记预存问题，只标记本次变更引入的问题
- 不标记需要假设的问题（如"可能影响其他模块"）

### 关于行范围

- 尽可能短（≤ 5-10 行）
- 精确定位问题所在
- 必须与 diff 重叠

### 关于代码建议

- 只在有具体替换代码时使用 ```suggestion 块
- 保持最少行数，不在块内添加注释
- 精确保留原始缩进（空格 vs tab，空格数量）
- 不改变外层缩进级别（除非这是修复本身）

### 关于多轮审查

- 每轮审查生成独立的报告文件
- 问题 ID 在所有轮次中保持一致
- 清晰标注问题的首次发现轮次
- 显示修复进度，避免重复提示已修复或已接受的问题
- 如果问题持续 3 轮未修复且未标记为 acceptable，提高优先级提示

### 关于状态转换

- `open` → `fixed`：代码中已不存在该问题
- `open` → `acceptable`：用户明确表示可接受
- `acceptable` 和 `fixed` 状态不可逆（除非重新发现相同问题）

### 关于自动化工具

优先使用项目配置的自动化工具：

- Linter（ESLint, Pylint, Ruff 等）
- 类型检查（TypeScript, mypy 等）
- 安全扫描（npm audit, Snyk, Bandit 等）
- 测试覆盖率（coverage.py, Istanbul 等）

将工具输出整合到审查报告中，但仍需人工判断是否符合标记标准。

### 关于整体正确性

- 只有 P0/P1 问题会导致 `patch is incorrect`
- P2/P3 问题不影响整体正确性判断
- 风格、文档、拼写等非阻塞问题不影响判断
- 多轮审查中，如果所有 P0/P1 问题都已 `fixed` 或 `acceptable`，判断为 `patch is correct`
