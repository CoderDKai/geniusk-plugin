---
name: code-review
description: "在 implement 完成后使用。审查代码质量、安全性、性能，对照 design.md 验证实现，生成结构化审查报告。"
disable-model-invocation: true
---

# 代码审查：从实现到质量

## 你的角色

你是代码审查员。读取实现的代码、技术设计和测试场景，识别会影响准确性、性能、安全性或可维护性的问题，给出具体的、可操作的改进建议。

## 流程

### 第一步：读取上下文

- 读取同目录下的 `prd.md`（需求文档）
- 读取同目录下的 `cases.md`（测试场景）
- 读取同目录下的 `design.md`（技术设计）
- 读取同目录下的 `plan.md`（任务计划）
- 使用 `git log` 查看最近的 commits（识别本次变更范围）
- 使用 `git diff` 获取本次变更的代码差异
- 读取变更涉及的源代码和测试代码

### 第二步：确认审查范围

询问用户选择审查范围：

1. **完整审查（推荐）** - 审查所有维度，输出结构化报告
2. **快速审查** - 只标记 P0/P1 问题
3. **专项审查** - 选择特定维度（安全/性能/设计一致性）

**默认推荐**：完整审查

### 第三步：多维度审查

按以下维度审查代码，识别符合标准的问题：

#### 3.1 设计一致性

**检查项**：
- 实现是否符合 design.md 中的架构设计
- 模块划分、接口定义、数据模型是否与设计一致
- 偏离设计是否有合理原因

**问题判定**：
- 只标记明显偏离设计且无合理理由的实现
- 不标记有意的设计改进（除非破坏了其他部分）

#### 3.2 场景覆盖

**检查项**：
- 对照 plan.md 中的场景覆盖矩阵
- 检查每个 TC-* 场景是否有对应的测试
- 检查测试是否真正覆盖了场景的所有条件

**问题判定**：
- 标记完全缺失的场景测试
- 标记测试覆盖不完整的场景（如只测了正常路径，未测异常）
- 不标记测试风格问题

#### 3.3 代码质量

**检查项**：
- 明显影响可读性的命名或结构
- 过高的复杂度（圈复杂度 > 10）
- 明显的重复代码（3次以上）
- 缺失的关键错误处理
- 未处理的边界条件

**问题判定**：
- 只标记会实质影响可维护性的问题
- 不标记风格偏好（除非违反项目规范）
- 不标记需要过度重构的问题（除非代码库其他部分已有高标准）
#### 3.4 安全性

**检查项**：
- 输入验证缺失（SQL 注入、XSS、命令注入风险）
- 认证授权问题（权限检查缺失、会话管理不当）
- 敏感数据处理（明文存储、日志泄露）
- 依赖库已知漏洞
- OWASP Top 10 常见漏洞

**问题判定**：
- 标记明确的安全漏洞（P0/P1）
- 标记缺失的输入验证（如果涉及用户输入或外部数据）
- 不标记理论上的风险（必须有具体的攻击场景）

#### 3.5 性能

**检查项**：
- 明显的算法问题（如 O(n²) 可优化为 O(n)）
- 数据库 N+1 查询问题
- 资源泄漏（未关闭的连接、文件句柄）
- 不必要的重复计算
- 阻塞主线程的耗时操作

**问题判定**：
- 只标记会实际影响性能的问题
- 必须说明在什么场景下会出现性能问题
- 不标记微优化（除非 cases.md 中有性能要求）

#### 3.6 正确性

**检查项**：
- 逻辑错误（会导致功能不正确）
- 边界条件处理错误
- 并发问题（竞态条件、死锁）
- 类型错误或空指针风险
- 错误的假设或依赖

**问题判定**：
- 这是最高优先级的检查
- 标记所有会导致功能错误的问题
- 必须明确说明在什么输入/环境下会出错

### 第四步：问题判定标准

每个问题必须满足以下所有条件才标记：

1. **实质影响**：会影响准确性、性能、安全性或可维护性
2. **离散可操作**：是具体的单一问题，不是笼统的代码库问题
3. **匹配严格度**：修复不需要超出代码库现有标准的严格度
4. **本次引入**：是本次变更引入的，不是预存问题
5. **作者会修复**：原作者知道后很可能会修复
6. **无需假设**：不依赖未说明的假设
7. **可证明影响**：如果影响其他代码，必须指出具体位置
8. **非有意变更**：明显不是作者的有意设计

### 第五步：生成结构化报告

将审查结果整理成 JSON 格式：

```json
{
  "review_round": 1,
  "review_date": "YYYY-MM-DD HH:MM:SS",
  "commit_range": "abc123..def456",
  "findings": [
    {
      "id": "CR-001",
      "title": "[P1] 未验证用户输入导致 SQL 注入风险",
      "body": "在 `src/api/users.ts:42` 中，`username` 参数直接拼接到 SQL 查询中，未进行转义或使用参数化查询。攻击者可通过构造特殊输入（如 `' OR '1'='1`）绕过认证。应使用参数化查询或 ORM 的安全方法。",
      "confidence_score": 0.95,
      "priority": 1,
      "status": "open",
      "first_seen_round": 1,
      "code_location": {
        "absolute_file_path": "/path/to/src/api/users.ts",
        "line_range": {"start": 42, "end": 44}
      }
    }
  ],
  "overall_correctness": "patch is incorrect",
  "overall_explanation": "存在 1 个 P1 安全问题会导致 SQL 注入漏洞，必须修复后才能合并。",
  "overall_confidence_score": 0.95
}
```

**字段说明**：

- `review_round`：审查轮次（1, 2, 3...）
- `review_date`：审查时间
- `commit_range`：审查的 commit 范围
- `id`：问题唯一标识（CR-001, CR-002...）
- `title`：≤ 80 字符，祈使句，以优先级标签开头
- `body`：1 段 Markdown，说明为什么是问题，引用文件/行号/函数
- `confidence_score`：0.0-1.0，表示判断的置信度
- `priority`：0-3（P0=0, P1=1, P2=2, P3=3）
- `status`：问题状态
  - `open`：待修复
  - `fixed`：已修复
  - `acceptable`：用户认为可接受/这是预期行为
- `first_seen_round`：首次发现该问题的轮次
- `code_location`：必须包含绝对路径和行范围
- `line_range`：尽可能短（≤ 5-10 行），精确定位问题

**优先级定义**：

- **P0**：立即修复。阻塞发布、运营或主要功能。仅用于不依赖任何输入假设的普遍问题
- **P1**：紧急。应在下个周期修复
- **P2**：正常。最终需要修复
- **P3**：低优先级。锦上添花

**整体正确性判断**：

- `patch is correct`：现有代码和测试不会破坏，补丁无 bug 和阻塞问题
- `patch is incorrect`：存在 P0/P1 问题或会破坏现有功能

忽略非阻塞问题（风格、格式、拼写、文档等）。

### 第六步：多轮审查处理

**首次审查**（review_round = 1）：

1. 生成 `review-round-1.json` 和 `review-round-1.md`
2. 所有问题状态为 `open`
3. 询问用户："发现 X 个问题（P0: X, P1: X, P2: X, P3: X），如何处理？"

**后续审查**（review_round > 1）：

1. 读取上一轮的 `review-round-N.json`
2. 对比本轮和上一轮的问题：
   - **已修复**：上一轮状态为 `open`，本轮代码中已不存在 → 更新为 `fixed`
   - **新问题**：本轮新增的问题 → 状态为 `open`，记录 `first_seen_round`
   - **持续存在**：两轮都存在且上一轮为 `open` → 保持 `open`，提示已存在 N 轮
   - **已接受问题**：上一轮状态为 `acceptable` → 不再提示，保持 `acceptable`
3. 生成 `review-round-N.json` 和 `review-round-N.md`
4. 在报告中显示：
   - 本轮新增问题
   - 上轮已修复问题（状态变为 `fixed`）
   - 持续存在的 `open` 问题（标注存在轮次）
   - 不显示 `acceptable` 和 `fixed` 的问题

**问题追踪示例**：

第 1 轮审查：
```json
{
  "review_round": 1,
  "findings": [
    {"id": "CR-001", "status": "open", "first_seen_round": 1},
    {"id": "CR-002", "status": "open", "first_seen_round": 1}
  ]
}
```

用户修复了 CR-002，将 CR-001 标记为 acceptable。

第 2 轮审查：
```json
{
  "review_round": 2,
  "findings": [
    {"id": "CR-001", "status": "acceptable", "first_seen_round": 1},
    {"id": "CR-002", "status": "fixed", "first_seen_round": 1, "fixed_in_round": 2},
    {"id": "CR-003", "status": "open", "first_seen_round": 2}
  ]
}
```

**用户交互**：

首次审查后询问：
- "修复所有问题"
- "修复 P0/P1 问题"
- "选择要修复的问题"
- "标记某些问题为 acceptable"
- "接受当前状态，继续下一步"

后续审查后显示：
- "已修复：X 个问题"
- "新增：X 个问题"
- "仍待处理：X 个 open 问题"
- 询问下一步操作

### 第七步：评论质量要求

每个问题的 `body` 必须：

1. **明确说明为什么是问题**
2. **准确传达严重程度**（不夸大）
3. **简洁**（最多 1 段，避免不必要的换行）
4. **代码片段 ≤ 3 行**（用 inline code 或 code block）
5. **明确触发条件**（说明什么场景/环境/输入会触发）
6. **语气客观**（不指责，不过度恭维，不用"Great job"、"Thanks for"）
7. **易于理解**（原作者无需仔细阅读即可理解）
8. **避免无用的恭维**

### 第八步：输出报告

**文件结构**：

```
docs/plans/YYYY-MM-DD/<主题>/
├── review-round-1.json      # 第 1 轮结构化报告
├── review-round-1.md        # 第 1 轮人类可读报告
├── review-round-2.json      # 第 2 轮结构化报告
├── review-round-2.md        # 第 2 轮人类可读报告
└── review-summary.md        # 所有轮次汇总
```

**Markdown 报告格式**：

```markdown
# 代码审查报告 - 第 N 轮

> 审查日期：YYYY-MM-DD HH:MM:SS
> Commit 范围：abc123..def456

## 审查概要

- 变更规模：X 个文件，+Y/-Z 行
- 本轮问题：X 个（P0: X, P1: X, P2: X, P3: X）
- 已修复：X 个（自上轮以来）
- 已接受：X 个（用户标记为 acceptable）
- 整体判断：patch is correct / patch is incorrect

## 本轮新增问题

### [P1] CR-003: 缺少错误处理

**位置**：`src/api/handler.ts:25-27`

**描述**：...

**建议**：...

## 持续存在的问题

### [P1] CR-001: 未验证用户输入导致 SQL 注入风险

**位置**：`src/api/users.ts:42-44`

**首次发现**：第 1 轮（已存在 2 轮）

**描述**：...

## 已修复问题

### [P1] CR-002: 资源泄漏

**修复于**：第 2 轮

## 场景覆盖检查

| 场景编号 | 状态 | 备注 |
|---------|------|------|
| TC-PARAM-001 | ✓ 已覆盖 | |
| TC-SEC-001 | ✗ 未覆盖 | 缺少 SQL 注入测试 |

## 正面反馈

- 错误处理逻辑清晰
- 测试覆盖率提升至 85%
```

### 第九步：用户交互

**首次审查**：
- 呈现审查报告
- 如果 `overall_correctness` 是 `patch is incorrect`，询问："发现 X 个阻塞问题，如何处理？"
- 如果 `overall_correctness` 是 `patch is correct`，询问："代码审查通过，是否继续下一步？"

**后续审查**：
- 显示修复进度："已修复 X 个，已接受 X 个，仍有 X 个待处理"
- 列出本轮新增问题和持续存在的问题
- 询问："如何处理剩余问题？"

**用户可选操作**：
1. 修复问题（进入修复流程）
2. 标记问题为 `acceptable`（用户认为这是预期行为或可接受）
3. 继续下一步（接受当前状态）

## 修复问题（可选）

如果用户选择修复问题：

1. 按优先级（P0 → P1 → P2 → P3）逐个修复
2. 每修复一个问题：
   - 修改代码
   - 运行相关测试
   - 提交 commit：`fix: <问题描述> (CR-<编号>)`
3. 修复完成后：
   - 运行完整测试套件
   - 询问："是否重新审查？"
   - 如果是，进入下一轮审查（review_round + 1）

## 标记为 acceptable

如果用户认为某个问题是可接受的：

1. 询问原因（记录到 JSON 中）
2. 更新问题状态为 `acceptable`
3. 该问题在后续审查中不再提示
4. 在 review-summary.md 中记录接受原因

## 输出

- `docs/plans/YYYY-MM-DD/<主题>/review-round-N.json`（结构化报告）
- `docs/plans/YYYY-MM-DD/<主题>/review-round-N.md`（人类可读报告）
- `docs/plans/YYYY-MM-DD/<主题>/review-summary.md`（所有轮次汇总）

## 原则

- **客观公正** - 基于明确标准，不主观臆断
- **具体明确** - 指出具体位置和问题，不泛泛而谈
- **可操作** - 建议具体可执行，不空洞
- **分清轻重** - 严格按优先级分类
- **简洁直接** - 评论简短，易于理解
- **尊重设计** - 如果实现偏离设计，先确认是否有合理原因
- **避免过度** - 不标记风格偏好、微优化、理论风险
- **追踪进度** - 多轮审查时清晰显示修复进度
- **尊重判断** - 用户标记为 acceptable 的问题不再提示

## 注意事项

### 关于问题判定

- 必须同时满足第四步的 8 个条件
- 不确定的问题不标记（confidence_score < 0.7）
- 不标记预存问题，只标记本次变更引入的问题
- 不标记需要假设的问题（如"可能影响其他模块"）

### 关于行范围

- 尽可能短（≤ 5-10 行）
- 精确定位问题所在
- 必须与 diff 重叠

### 关于代码建议

- 只在有具体替换代码时使用 ```suggestion 块
- 保持最少行数，不在块内添加注释
- 精确保留原始缩进（空格 vs tab，空格数量）
- 不改变外层缩进级别（除非这是修复本身）

### 关于多轮审查

- 每轮审查生成独立的报告文件
- 问题 ID 在所有轮次中保持一致
- 清晰标注问题的首次发现轮次
- 显示修复进度，避免重复提示已修复或已接受的问题
- 如果问题持续 3 轮未修复且未标记为 acceptable，提高优先级提示

### 关于状态转换

- `open` → `fixed`：代码中已不存在该问题
- `open` → `acceptable`：用户明确表示可接受
- `acceptable` 和 `fixed` 状态不可逆（除非重新发现相同问题）

### 关于自动化工具

优先使用项目配置的自动化工具：

- Linter（ESLint, Pylint, Ruff 等）
- 类型检查（TypeScript, mypy 等）
- 安全扫描（npm audit, Snyk, Bandit 等）
- 测试覆盖率（coverage.py, Istanbul 等）

将工具输出整合到审查报告中，但仍需人工判断是否符合标记标准。

### 关于整体正确性

- 只有 P0/P1 问题会导致 `patch is incorrect`
- P2/P3 问题不影响整体正确性判断
- 风格、文档、拼写等非阻塞问题不影响判断
- 多轮审查中，如果所有 P0/P1 问题都已 `fixed` 或 `acceptable`，判断为 `patch is correct`
